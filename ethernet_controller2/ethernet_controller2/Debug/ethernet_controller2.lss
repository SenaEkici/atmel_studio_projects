
ethernet_controller2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800100  0000083a  000008ce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000083a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000c  0080010a  0080010a  000008d8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000008d8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000908  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000a0  00000000  00000000  00000948  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001bf6  00000000  00000000  000009e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a94  00000000  00000000  000025de  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000009b2  00000000  00000000  00003072  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001b0  00000000  00000000  00003a24  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005c0  00000000  00000000  00003bd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000a9b  00000000  00000000  00004194  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000080  00000000  00000000  00004c2f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3b 00 	jmp	0x76	; 0x76 <__ctors_end>
   4:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
   8:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
   c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  10:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  14:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  18:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  1c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  20:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  24:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  28:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  2c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  30:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  34:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  38:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  3c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  40:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  44:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  48:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  4c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  50:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  54:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  58:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  5c:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  60:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  64:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>
  68:	0c 94 58 00 	jmp	0xb0	; 0xb0 <__bad_interrupt>

0000006c <__trampolines_end>:
  6c:	08 06       	cpc	r0, r24
  6e:	00 01       	movw	r0, r0
  70:	08 00       	.word	0x0008	; ????
  72:	06 04       	cpc	r0, r6
  74:	00 01       	movw	r0, r0

00000076 <__ctors_end>:
  76:	11 24       	eor	r1, r1
  78:	1f be       	out	0x3f, r1	; 63
  7a:	cf ef       	ldi	r28, 0xFF	; 255
  7c:	d4 e0       	ldi	r29, 0x04	; 4
  7e:	de bf       	out	0x3e, r29	; 62
  80:	cd bf       	out	0x3d, r28	; 61

00000082 <__do_copy_data>:
  82:	11 e0       	ldi	r17, 0x01	; 1
  84:	a0 e0       	ldi	r26, 0x00	; 0
  86:	b1 e0       	ldi	r27, 0x01	; 1
  88:	ea e3       	ldi	r30, 0x3A	; 58
  8a:	f8 e0       	ldi	r31, 0x08	; 8
  8c:	02 c0       	rjmp	.+4      	; 0x92 <__do_copy_data+0x10>
  8e:	05 90       	lpm	r0, Z+
  90:	0d 92       	st	X+, r0
  92:	aa 30       	cpi	r26, 0x0A	; 10
  94:	b1 07       	cpc	r27, r17
  96:	d9 f7       	brne	.-10     	; 0x8e <__do_copy_data+0xc>

00000098 <__do_clear_bss>:
  98:	21 e0       	ldi	r18, 0x01	; 1
  9a:	aa e0       	ldi	r26, 0x0A	; 10
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	01 c0       	rjmp	.+2      	; 0xa2 <.do_clear_bss_start>

000000a0 <.do_clear_bss_loop>:
  a0:	1d 92       	st	X+, r1

000000a2 <.do_clear_bss_start>:
  a2:	a6 31       	cpi	r26, 0x16	; 22
  a4:	b2 07       	cpc	r27, r18
  a6:	e1 f7       	brne	.-8      	; 0xa0 <.do_clear_bss_loop>
  a8:	0e 94 c0 03 	call	0x780	; 0x780 <main>
  ac:	0c 94 1b 04 	jmp	0x836	; 0x836 <_exit>

000000b0 <__bad_interrupt>:
  b0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b4 <enc28j60ReadOp>:

/// Read a control register in the controller assuming that the currently
/// selected bank is correct
uint8_t enc28j60ReadOp( uint8_t op, uint8_t address)
{
	CSACTIVE;
  b4:	2a 98       	cbi	0x05, 2	; 5
	// issue read command
	SPDR = op | (address & ADDR_MASK);
  b6:	96 2f       	mov	r25, r22
  b8:	6f 71       	andi	r22, 0x1F	; 31
  ba:	86 2b       	or	r24, r22
  bc:	8e bd       	out	0x2e, r24	; 46
	waitspi();
  be:	0d b4       	in	r0, 0x2d	; 45
  c0:	07 fe       	sbrs	r0, 7
  c2:	fd cf       	rjmp	.-6      	; 0xbe <enc28j60ReadOp+0xa>
	// read data
	SPDR = 0x00;
  c4:	1e bc       	out	0x2e, r1	; 46
	waitspi();
  c6:	0d b4       	in	r0, 0x2d	; 45
  c8:	07 fe       	sbrs	r0, 7
  ca:	fd cf       	rjmp	.-6      	; 0xc6 <enc28j60ReadOp+0x12>
	// do dummy read if needed (for mac and mii, see datasheet page 29)
	if(address & 0x80)
  cc:	99 23       	and	r25, r25
  ce:	24 f4       	brge	.+8      	; 0xd8 <enc28j60ReadOp+0x24>
	{
		SPDR = 0x00;
  d0:	1e bc       	out	0x2e, r1	; 46
		waitspi();
  d2:	0d b4       	in	r0, 0x2d	; 45
  d4:	07 fe       	sbrs	r0, 7
  d6:	fd cf       	rjmp	.-6      	; 0xd2 <enc28j60ReadOp+0x1e>
	}
	// release CS
	CSPASSIVE;
  d8:	2a 9a       	sbi	0x05, 2	; 5
	return(SPDR);
  da:	8e b5       	in	r24, 0x2e	; 46
}
  dc:	08 95       	ret

000000de <enc28j60WriteOp>:

/// Write a control register in the controller assuming that the currently
/// selected bank is correct
void enc28j60WriteOp( uint8_t op, uint8_t address, uint8_t data)
{
	CSACTIVE;
  de:	2a 98       	cbi	0x05, 2	; 5
	// issue write command
	SPDR = op | (address & ADDR_MASK);
  e0:	6f 71       	andi	r22, 0x1F	; 31
  e2:	86 2b       	or	r24, r22
  e4:	8e bd       	out	0x2e, r24	; 46
	waitspi();
  e6:	0d b4       	in	r0, 0x2d	; 45
  e8:	07 fe       	sbrs	r0, 7
  ea:	fd cf       	rjmp	.-6      	; 0xe6 <enc28j60WriteOp+0x8>
	// write data
	SPDR = data;
  ec:	4e bd       	out	0x2e, r20	; 46
	waitspi();
  ee:	0d b4       	in	r0, 0x2d	; 45
  f0:	07 fe       	sbrs	r0, 7
  f2:	fd cf       	rjmp	.-6      	; 0xee <enc28j60WriteOp+0x10>
	CSPASSIVE;
  f4:	2a 9a       	sbi	0x05, 2	; 5
  f6:	08 95       	ret

000000f8 <enc28j60SetBank>:

// -----------------------------------------------------------------------------

/// Set the control register bank to use  
void enc28j60SetBank( uint8_t bank)
{
  f8:	cf 93       	push	r28
	// set the bank
	if (bank != gBank)
  fa:	90 91 0c 01 	lds	r25, 0x010C	; 0x80010c <gBank>
  fe:	98 17       	cp	r25, r24
 100:	71 f0       	breq	.+28     	; 0x11e <enc28j60SetBank+0x26>
 102:	c8 2f       	mov	r28, r24
	{
		enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
 104:	43 e0       	ldi	r20, 0x03	; 3
 106:	6f e1       	ldi	r22, 0x1F	; 31
 108:	80 ea       	ldi	r24, 0xA0	; 160
 10a:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
		enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (bank & 0x03));
 10e:	4c 2f       	mov	r20, r28
 110:	43 70       	andi	r20, 0x03	; 3
 112:	6f e1       	ldi	r22, 0x1F	; 31
 114:	80 e8       	ldi	r24, 0x80	; 128
 116:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
		gBank = bank;
 11a:	c0 93 0c 01 	sts	0x010C, r28	; 0x80010c <gBank>
	}		
}
 11e:	cf 91       	pop	r28
 120:	08 95       	ret

00000122 <enc28j60ReadBuffer>:

// -----------------------------------------------------------------------------

/// Read from the Buffer Memory
void enc28j60ReadBuffer( uint8_t len, uint8_t* data)
{
 122:	fb 01       	movw	r30, r22
	CSACTIVE;
 124:	2a 98       	cbi	0x05, 2	; 5
	// issue read command
	SPDR = ENC28J60_READ_BUF_MEM;
 126:	9a e3       	ldi	r25, 0x3A	; 58
 128:	9e bd       	out	0x2e, r25	; 46
	waitspi();
 12a:	0d b4       	in	r0, 0x2d	; 45
 12c:	07 fe       	sbrs	r0, 7
 12e:	fd cf       	rjmp	.-6      	; 0x12a <enc28j60ReadBuffer+0x8>
	while(len)
 130:	88 23       	and	r24, r24
 132:	49 f0       	breq	.+18     	; 0x146 <enc28j60ReadBuffer+0x24>
	{
		len--;
 134:	81 50       	subi	r24, 0x01	; 1
		// read data
		SPDR = 0x00;
 136:	1e bc       	out	0x2e, r1	; 46
		waitspi();
 138:	0d b4       	in	r0, 0x2d	; 45
 13a:	07 fe       	sbrs	r0, 7
 13c:	fd cf       	rjmp	.-6      	; 0x138 <enc28j60ReadBuffer+0x16>
		*data = SPDR;
 13e:	9e b5       	in	r25, 0x2e	; 46
 140:	91 93       	st	Z+, r25
{
	CSACTIVE;
	// issue read command
	SPDR = ENC28J60_READ_BUF_MEM;
	waitspi();
	while(len)
 142:	81 11       	cpse	r24, r1
 144:	f7 cf       	rjmp	.-18     	; 0x134 <enc28j60ReadBuffer+0x12>
		SPDR = 0x00;
		waitspi();
		*data = SPDR;
		data++;
	}
	CSPASSIVE;
 146:	2a 9a       	sbi	0x05, 2	; 5
 148:	08 95       	ret

0000014a <enc28j60WriteBuffer>:

// -----------------------------------------------------------------------------

/// Write to the Buffer Memory
void enc28j60WriteBuffer( uint8_t len, uint8_t* data)
{
 14a:	fb 01       	movw	r30, r22
	CSACTIVE;
 14c:	2a 98       	cbi	0x05, 2	; 5
	// issue write command
	SPDR = ENC28J60_WRITE_BUF_MEM;
 14e:	9a e7       	ldi	r25, 0x7A	; 122
 150:	9e bd       	out	0x2e, r25	; 46
	waitspi();
 152:	0d b4       	in	r0, 0x2d	; 45
 154:	07 fe       	sbrs	r0, 7
 156:	fd cf       	rjmp	.-6      	; 0x152 <enc28j60WriteBuffer+0x8>
 158:	07 c0       	rjmp	.+14     	; 0x168 <enc28j60WriteBuffer+0x1e>
	while(len)
	{
		len--;
 15a:	81 50       	subi	r24, 0x01	; 1
		// write data
		SPDR = *data;
 15c:	91 91       	ld	r25, Z+
 15e:	9e bd       	out	0x2e, r25	; 46
		data++;
		waitspi();
 160:	0d b4       	in	r0, 0x2d	; 45
 162:	07 fe       	sbrs	r0, 7
 164:	fd cf       	rjmp	.-6      	; 0x160 <enc28j60WriteBuffer+0x16>
 166:	03 c0       	rjmp	.+6      	; 0x16e <enc28j60WriteBuffer+0x24>
{
	CSACTIVE;
	// issue write command
	SPDR = ENC28J60_WRITE_BUF_MEM;
	waitspi();
	while(len)
 168:	81 11       	cpse	r24, r1
 16a:	f7 cf       	rjmp	.-18     	; 0x15a <enc28j60WriteBuffer+0x10>
 16c:	02 c0       	rjmp	.+4      	; 0x172 <enc28j60WriteBuffer+0x28>
 16e:	81 11       	cpse	r24, r1
 170:	f4 cf       	rjmp	.-24     	; 0x15a <enc28j60WriteBuffer+0x10>
		// write data
		SPDR = *data;
		data++;
		waitspi();
	}
	CSPASSIVE;
 172:	2a 9a       	sbi	0x05, 2	; 5
 174:	08 95       	ret

00000176 <enc28j60PhyReadH>:

// -----------------------------------------------------------------------------

/// Read upper 8 bits of a PHY register
uint8_t enc28j60PhyReadH( uint8_t address)
{
 176:	cf 93       	push	r28
 178:	c8 2f       	mov	r28, r24

	// Set the right address and start the register read operation
	enc28j60SetBank(2);
 17a:	82 e0       	ldi	r24, 0x02	; 2
 17c:	0e 94 7c 00 	call	0xf8	; 0xf8 <enc28j60SetBank>
	enc28j60WriteReg(MIREGADR, address);
 180:	4c 2f       	mov	r20, r28
 182:	64 ed       	ldi	r22, 0xD4	; 212
 184:	80 e4       	ldi	r24, 0x40	; 64
 186:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(MICMD, MICMD_MIIRD);
 18a:	41 e0       	ldi	r20, 0x01	; 1
 18c:	62 ed       	ldi	r22, 0xD2	; 210
 18e:	80 e4       	ldi	r24, 0x40	; 64
 190:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 194:	8e e3       	ldi	r24, 0x3E	; 62
 196:	8a 95       	dec	r24
 198:	f1 f7       	brne	.-4      	; 0x196 <enc28j60PhyReadH+0x20>
 19a:	00 c0       	rjmp	.+0      	; 0x19c <enc28j60PhyReadH+0x26>
	_delay_us(15);

	// wait until the PHY read completes
	enc28j60SetBank(3);
 19c:	83 e0       	ldi	r24, 0x03	; 3
 19e:	0e 94 7c 00 	call	0xf8	; 0xf8 <enc28j60SetBank>
	while(enc28j60ReadReg(MISTAT) & MISTAT_BUSY)
 1a2:	6a ee       	ldi	r22, 0xEA	; 234
 1a4:	80 e0       	ldi	r24, 0x00	; 0
 1a6:	0e 94 5a 00 	call	0xb4	; 0xb4 <enc28j60ReadOp>
 1aa:	80 fd       	sbrc	r24, 0
 1ac:	fa cf       	rjmp	.-12     	; 0x1a2 <enc28j60PhyReadH+0x2c>
		;

	// reset reading bit
	enc28j60SetBank(2);
 1ae:	82 e0       	ldi	r24, 0x02	; 2
 1b0:	0e 94 7c 00 	call	0xf8	; 0xf8 <enc28j60SetBank>
	enc28j60WriteReg(MICMD, 0x00);
 1b4:	40 e0       	ldi	r20, 0x00	; 0
 1b6:	62 ed       	ldi	r22, 0xD2	; 210
 1b8:	80 e4       	ldi	r24, 0x40	; 64
 1ba:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	return (enc28j60ReadReg(MIRDH));
 1be:	69 ed       	ldi	r22, 0xD9	; 217
 1c0:	80 e0       	ldi	r24, 0x00	; 0
 1c2:	0e 94 5a 00 	call	0xb4	; 0xb4 <enc28j60ReadOp>
}
 1c6:	cf 91       	pop	r28
 1c8:	08 95       	ret

000001ca <enc28j60PhyWrite>:

// -----------------------------------------------------------------------------

/// Write a PHY register
void enc28j60PhyWrite( uint8_t address, uint16_t data)
{
 1ca:	1f 93       	push	r17
 1cc:	cf 93       	push	r28
 1ce:	df 93       	push	r29
 1d0:	18 2f       	mov	r17, r24
 1d2:	d6 2f       	mov	r29, r22
 1d4:	c7 2f       	mov	r28, r23
	enc28j60SetBank(2);
 1d6:	82 e0       	ldi	r24, 0x02	; 2
 1d8:	0e 94 7c 00 	call	0xf8	; 0xf8 <enc28j60SetBank>
	
	// set the PHY register address
	enc28j60WriteReg(MIREGADR, address);
 1dc:	41 2f       	mov	r20, r17
 1de:	64 ed       	ldi	r22, 0xD4	; 212
 1e0:	80 e4       	ldi	r24, 0x40	; 64
 1e2:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// write the PHY data
	enc28j60WriteReg(MIWRL, data);
 1e6:	4d 2f       	mov	r20, r29
 1e8:	66 ed       	ldi	r22, 0xD6	; 214
 1ea:	80 e4       	ldi	r24, 0x40	; 64
 1ec:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(MIWRH, data>>8);
 1f0:	4c 2f       	mov	r20, r28
 1f2:	67 ed       	ldi	r22, 0xD7	; 215
 1f4:	80 e4       	ldi	r24, 0x40	; 64
 1f6:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// wait until the PHY write completes
	enc28j60SetBank(3);
 1fa:	83 e0       	ldi	r24, 0x03	; 3
 1fc:	0e 94 7c 00 	call	0xf8	; 0xf8 <enc28j60SetBank>
	while(enc28j60ReadReg(MISTAT) & MISTAT_BUSY)
 200:	04 c0       	rjmp	.+8      	; 0x20a <enc28j60PhyWrite+0x40>
 202:	8e e3       	ldi	r24, 0x3E	; 62
 204:	8a 95       	dec	r24
 206:	f1 f7       	brne	.-4      	; 0x204 <enc28j60PhyWrite+0x3a>
 208:	00 c0       	rjmp	.+0      	; 0x20a <enc28j60PhyWrite+0x40>
 20a:	6a ee       	ldi	r22, 0xEA	; 234
 20c:	80 e0       	ldi	r24, 0x00	; 0
 20e:	0e 94 5a 00 	call	0xb4	; 0xb4 <enc28j60ReadOp>
 212:	80 fd       	sbrc	r24, 0
 214:	f6 cf       	rjmp	.-20     	; 0x202 <enc28j60PhyWrite+0x38>
	{
		_delay_us(15);
	}
}
 216:	df 91       	pop	r29
 218:	cf 91       	pop	r28
 21a:	1f 91       	pop	r17
 21c:	08 95       	ret

0000021e <enc28j60Init>:

// -----------------------------------------------------------------------------

void enc28j60Init( uint8_t* macaddr)
{
 21e:	0f 93       	push	r16
 220:	1f 93       	push	r17
 222:	cf 93       	push	r28
 224:	8c 01       	movw	r16, r24
	gBank = 0xFF; // non-existent 
 226:	8f ef       	ldi	r24, 0xFF	; 255
 228:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <gBank>
	
	// Initialize atmel I/O
    ENC28J60_CONTROL_DDR |= 1<<ENC28J60_CONTROL_CS;
 22c:	22 9a       	sbi	0x04, 2	; 4
    CSPASSIVE; // ss=0
 22e:	2a 9a       	sbi	0x05, 2	; 5

    ENC28J60_CONTROL_DDR  |= 1<<ENC28J60_CONTROL_SI | 1<<ENC28J60_CONTROL_SCK; // mosi, sck output
 230:	84 b1       	in	r24, 0x04	; 4
 232:	88 62       	ori	r24, 0x28	; 40
 234:	84 b9       	out	0x04, r24	; 4
    ENC28J60_CONTROL_DDR|= 1<<ENC28J60_CONTROL_SO; // MISO is input
 236:	24 9a       	sbi	0x04, 4	; 4

    ENC28J60_CONTROL_PORT|= 1<<ENC28J60_CONTROL_SI; // MOSI low
 238:	2b 9a       	sbi	0x05, 3	; 5
    ENC28J60_CONTROL_PORT|= 1<<ENC28J60_CONTROL_SCK; // SCK low
 23a:	2d 9a       	sbi	0x05, 5	; 5

	// Initialize atmel SPI interface
	// master mode and Fosc/2 clock:
	SPCR = (1<<SPE)|(1<<MSTR);
 23c:	80 e5       	ldi	r24, 0x50	; 80
 23e:	8c bd       	out	0x2c, r24	; 44
	SPSR |= (1<<SPI2X);
 240:	8d b5       	in	r24, 0x2d	; 45
 242:	81 60       	ori	r24, 0x01	; 1
 244:	8d bd       	out	0x2d, r24	; 45
	
	// Reset controller
	enc28j60WriteOp(ENC28J60_SOFT_RESET, 0x1F, ENC28J60_SOFT_RESET);
 246:	4f ef       	ldi	r20, 0xFF	; 255
 248:	6f e1       	ldi	r22, 0x1F	; 31
 24a:	8f ef       	ldi	r24, 0xFF	; 255
 24c:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 250:	27 e4       	ldi	r18, 0x47	; 71
 252:	88 ee       	ldi	r24, 0xE8	; 232
 254:	91 e0       	ldi	r25, 0x01	; 1
 256:	21 50       	subi	r18, 0x01	; 1
 258:	80 40       	sbci	r24, 0x00	; 0
 25a:	90 40       	sbci	r25, 0x00	; 0
 25c:	e1 f7       	brne	.-8      	; 0x256 <enc28j60Init+0x38>
 25e:	00 c0       	rjmp	.+0      	; 0x260 <enc28j60Init+0x42>
 260:	00 00       	nop
	_delay_ms(50); // Note that polling CLKRDY does not work. See Rev. B4 Silicon Errata point. Just wait.

	// A.S.A.P. setup CLKout: 2 is 12.5MHz:
	enc28j60SetBank(3);
 262:	83 e0       	ldi	r24, 0x03	; 3
 264:	0e 94 7c 00 	call	0xf8	; 0xf8 <enc28j60SetBank>
	enc28j60WriteReg(ECOCON, 2);
 268:	42 e0       	ldi	r20, 0x02	; 2
 26a:	65 e7       	ldi	r22, 0x75	; 117
 26c:	80 e4       	ldi	r24, 0x40	; 64
 26e:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	
	// Do bank 0 stuff
	enc28j60SetBank(0);
 272:	80 e0       	ldi	r24, 0x00	; 0
 274:	0e 94 7c 00 	call	0xf8	; 0xf8 <enc28j60SetBank>
	// Initialize receive buffer
	// 16-bit transfers, must write low byte first
	// Set receive buffer start address
	gNextPacketPtr = RXSTART_INIT;
 278:	10 92 0b 01 	sts	0x010B, r1	; 0x80010b <__data_end+0x1>
 27c:	10 92 0a 01 	sts	0x010A, r1	; 0x80010a <__data_end>
	// Rx start
	enc28j60WriteReg(ERXSTL, RXSTART_INIT&0xFF);
 280:	40 e0       	ldi	r20, 0x00	; 0
 282:	68 e0       	ldi	r22, 0x08	; 8
 284:	80 e4       	ldi	r24, 0x40	; 64
 286:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(ERXSTH, RXSTART_INIT>>8);
 28a:	40 e0       	ldi	r20, 0x00	; 0
 28c:	69 e0       	ldi	r22, 0x09	; 9
 28e:	80 e4       	ldi	r24, 0x40	; 64
 290:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// Set receive pointer address
	enc28j60WriteReg(ERXRDPTL, RXSTART_INIT&0xFF);
 294:	40 e0       	ldi	r20, 0x00	; 0
 296:	6c e0       	ldi	r22, 0x0C	; 12
 298:	80 e4       	ldi	r24, 0x40	; 64
 29a:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(ERXRDPTH, RXSTART_INIT>>8);
 29e:	40 e0       	ldi	r20, 0x00	; 0
 2a0:	6d e0       	ldi	r22, 0x0D	; 13
 2a2:	80 e4       	ldi	r24, 0x40	; 64
 2a4:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// RX end
	enc28j60WriteReg(ERXNDL, RXSTOP_INIT&0xFF);
 2a8:	4d ef       	ldi	r20, 0xFD	; 253
 2aa:	6a e0       	ldi	r22, 0x0A	; 10
 2ac:	80 e4       	ldi	r24, 0x40	; 64
 2ae:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(ERXNDH, RXSTOP_INIT>>8);
 2b2:	49 e1       	ldi	r20, 0x19	; 25
 2b4:	6b e0       	ldi	r22, 0x0B	; 11
 2b6:	80 e4       	ldi	r24, 0x40	; 64
 2b8:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// TX start
	enc28j60WriteReg(ETXSTL, TXSTART_INIT&0xFF);
 2bc:	4f ef       	ldi	r20, 0xFF	; 255
 2be:	64 e0       	ldi	r22, 0x04	; 4
 2c0:	80 e4       	ldi	r24, 0x40	; 64
 2c2:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(ETXSTH, TXSTART_INIT>>8);
 2c6:	49 e1       	ldi	r20, 0x19	; 25
 2c8:	65 e0       	ldi	r22, 0x05	; 5
 2ca:	80 e4       	ldi	r24, 0x40	; 64
 2cc:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// TX end (initialize for a packet with a payload of 1 byte)
	uint16_t address = (TXSTART_INIT + ETH_HEADER_LEN + 1);
	enc28j60WriteReg(ETXNDL, address & 0xFF);
 2d0:	4e e0       	ldi	r20, 0x0E	; 14
 2d2:	66 e0       	ldi	r22, 0x06	; 6
 2d4:	80 e4       	ldi	r24, 0x40	; 64
 2d6:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(ETXNDH, address >> 8);
 2da:	4a e1       	ldi	r20, 0x1A	; 26
 2dc:	67 e0       	ldi	r22, 0x07	; 7
 2de:	80 e4       	ldi	r24, 0x40	; 64
 2e0:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// Prepare the parts of the transmit packet that never change 
	// Write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteReg(EWRPTL, (TXSTART_INIT) & 0xFF);
 2e4:	4f ef       	ldi	r20, 0xFF	; 255
 2e6:	62 e0       	ldi	r22, 0x02	; 2
 2e8:	80 e4       	ldi	r24, 0x40	; 64
 2ea:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(EWRPTH, (TXSTART_INIT) >> 8);
 2ee:	49 e1       	ldi	r20, 0x19	; 25
 2f0:	63 e0       	ldi	r22, 0x03	; 3
 2f2:	80 e4       	ldi	r24, 0x40	; 64
 2f4:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
 2f8:	40 e0       	ldi	r20, 0x00	; 0
 2fa:	60 e0       	ldi	r22, 0x00	; 0
 2fc:	8a e7       	ldi	r24, 0x7A	; 122
 2fe:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
 302:	c6 e0       	ldi	r28, 0x06	; 6
	// Write broadcast address as DST MAC to have some default setting.
	// we can still overwrite later
	uint8_t i = 0;
	while (i < 6)
	{
		enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0xFF);	
 304:	4f ef       	ldi	r20, 0xFF	; 255
 306:	60 e0       	ldi	r22, 0x00	; 0
 308:	8a e7       	ldi	r24, 0x7A	; 122
 30a:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
 30e:	c1 50       	subi	r28, 0x01	; 1
	enc28j60WriteReg(EWRPTH, (TXSTART_INIT) >> 8);
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
	// Write broadcast address as DST MAC to have some default setting.
	// we can still overwrite later
	uint8_t i = 0;
	while (i < 6)
 310:	c9 f7       	brne	.-14     	; 0x304 <enc28j60Init+0xe6>
		enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0xFF);	
		i++;
	}
	// Set our MAC address as the SRC MAC into the transmit buffer
	// Set the write pointer to start of transmit buffer area
	enc28j60WriteBuffer(6, macaddr);
 312:	b8 01       	movw	r22, r16
 314:	86 e0       	ldi	r24, 0x06	; 6
 316:	0e 94 a5 00 	call	0x14a	; 0x14a <enc28j60WriteBuffer>
	// First EtherType/length byte is always 0, initialize second byte to 1 
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);	
 31a:	40 e0       	ldi	r20, 0x00	; 0
 31c:	60 e0       	ldi	r22, 0x00	; 0
 31e:	8a e7       	ldi	r24, 0x7A	; 122
 320:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x01);	
 324:	41 e0       	ldi	r20, 0x01	; 1
 326:	60 e0       	ldi	r22, 0x00	; 0
 328:	8a e7       	ldi	r24, 0x7A	; 122
 32a:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	
	// Do bank 1 stuff, packet filter: 
	enc28j60SetBank(1);
 32e:	81 e0       	ldi	r24, 0x01	; 1
 330:	0e 94 7c 00 	call	0xf8	; 0xf8 <enc28j60SetBank>
	// Only allow unicast packets destined for us and that have a correct CRC
	enc28j60WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN);
 334:	40 ea       	ldi	r20, 0xA0	; 160
 336:	68 e3       	ldi	r22, 0x38	; 56
 338:	80 e4       	ldi	r24, 0x40	; 64
 33a:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>

	// Do bank 2 stuff
	enc28j60SetBank(2);
 33e:	82 e0       	ldi	r24, 0x02	; 2
 340:	0e 94 7c 00 	call	0xf8	; 0xf8 <enc28j60SetBank>
	// Enable MAC receive, disable flow control (only needed in full-duplex)
	enc28j60WriteReg(MACON1, MACON1_MARXEN);
 344:	41 e0       	ldi	r20, 0x01	; 1
 346:	60 ec       	ldi	r22, 0xC0	; 192
 348:	80 e4       	ldi	r24, 0x40	; 64
 34a:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// Bring MAC out of reset
	enc28j60WriteReg(MACON2, 0x00);
 34e:	40 e0       	ldi	r20, 0x00	; 0
 350:	61 ec       	ldi	r22, 0xC1	; 193
 352:	80 e4       	ldi	r24, 0x40	; 64
 354:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// Enable automatic padding to 60bytes and CRC operations
	// Also, force half-duplex operation
	enc28j60WriteReg(MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN);
 358:	42 e3       	ldi	r20, 0x32	; 50
 35a:	62 ec       	ldi	r22, 0xC2	; 194
 35c:	80 e4       	ldi	r24, 0x40	; 64
 35e:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// Half-duplex only: back-off settings
	enc28j60WriteReg(MACON4, MACON4_DEFER|MACON4_BPEN|MACON4_NOBKOFF);
 362:	40 e7       	ldi	r20, 0x70	; 112
 364:	63 ec       	ldi	r22, 0xC3	; 195
 366:	80 e4       	ldi	r24, 0x40	; 64
 368:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// Set the maximum packet size which the controller will accept
	// Do not send packets longer than ENC28J60_MAX_PACKET_LEN:
	enc28j60WriteReg(MAMXFLL, ENC28J60_MAX_PACKET_LEN & 0xFF);
 36c:	41 e1       	ldi	r20, 0x11	; 17
 36e:	6a ec       	ldi	r22, 0xCA	; 202
 370:	80 e4       	ldi	r24, 0x40	; 64
 372:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(MAMXFLH, ENC28J60_MAX_PACKET_LEN >> 8);
 376:	41 e0       	ldi	r20, 0x01	; 1
 378:	6b ec       	ldi	r22, 0xCB	; 203
 37a:	80 e4       	ldi	r24, 0x40	; 64
 37c:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// set inter-frame gap (non-back-to-back)
	enc28j60WriteReg(MAIPGL, 0x12);
 380:	42 e1       	ldi	r20, 0x12	; 18
 382:	66 ec       	ldi	r22, 0xC6	; 198
 384:	80 e4       	ldi	r24, 0x40	; 64
 386:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(MAIPGH, 0x0C);
 38a:	4c e0       	ldi	r20, 0x0C	; 12
 38c:	67 ec       	ldi	r22, 0xC7	; 199
 38e:	80 e4       	ldi	r24, 0x40	; 64
 390:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// set inter-frame gap (back-to-back)
	enc28j60WriteReg(MABBIPG, 0x12);
 394:	42 e1       	ldi	r20, 0x12	; 18
 396:	64 ec       	ldi	r22, 0xC4	; 196
 398:	80 e4       	ldi	r24, 0x40	; 64
 39a:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	
	// Do bank 3 stuff
	enc28j60SetBank(3);
 39e:	83 e0       	ldi	r24, 0x03	; 3
 3a0:	0e 94 7c 00 	call	0xf8	; 0xf8 <enc28j60SetBank>
	// Write MAC address; NOTE: MAC address in ENC28J60 is byte-backward
	enc28j60WriteReg(MAADR5, macaddr[0]);
 3a4:	f8 01       	movw	r30, r16
 3a6:	40 81       	ld	r20, Z
 3a8:	64 ee       	ldi	r22, 0xE4	; 228
 3aa:	80 e4       	ldi	r24, 0x40	; 64
 3ac:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(MAADR4, macaddr[1]);
 3b0:	f8 01       	movw	r30, r16
 3b2:	41 81       	ldd	r20, Z+1	; 0x01
 3b4:	65 ee       	ldi	r22, 0xE5	; 229
 3b6:	80 e4       	ldi	r24, 0x40	; 64
 3b8:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(MAADR3, macaddr[2]);
 3bc:	f8 01       	movw	r30, r16
 3be:	42 81       	ldd	r20, Z+2	; 0x02
 3c0:	62 ee       	ldi	r22, 0xE2	; 226
 3c2:	80 e4       	ldi	r24, 0x40	; 64
 3c4:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(MAADR2, macaddr[3]);
 3c8:	f8 01       	movw	r30, r16
 3ca:	43 81       	ldd	r20, Z+3	; 0x03
 3cc:	63 ee       	ldi	r22, 0xE3	; 227
 3ce:	80 e4       	ldi	r24, 0x40	; 64
 3d0:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(MAADR1, macaddr[4]);
 3d4:	f8 01       	movw	r30, r16
 3d6:	44 81       	ldd	r20, Z+4	; 0x04
 3d8:	60 ee       	ldi	r22, 0xE0	; 224
 3da:	80 e4       	ldi	r24, 0x40	; 64
 3dc:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(MAADR0, macaddr[5]);
 3e0:	f8 01       	movw	r30, r16
 3e2:	45 81       	ldd	r20, Z+5	; 0x05
 3e4:	61 ee       	ldi	r22, 0xE1	; 225
 3e6:	80 e4       	ldi	r24, 0x40	; 64
 3e8:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	
	// Do PHY stuff
	// Magjack leds configuration, LEDB=yellow LEDA=green
	// 0x476 is PHLCON LEDA=link status, LEDB=receive/transmit
	// enc28j60PhyWrite(PHLCON,0b0000 0100 0111 01 10);
	enc28j60PhyWrite(PHLCON,0x476);
 3ec:	66 e7       	ldi	r22, 0x76	; 118
 3ee:	74 e0       	ldi	r23, 0x04	; 4
 3f0:	84 e1       	ldi	r24, 0x14	; 20
 3f2:	0e 94 e5 00 	call	0x1ca	; 0x1ca <enc28j60PhyWrite>
	// No loopback of transmitted frames
	enc28j60PhyWrite(PHCON2, PHCON2_HDLDIS);
 3f6:	60 e0       	ldi	r22, 0x00	; 0
 3f8:	71 e0       	ldi	r23, 0x01	; 1
 3fa:	80 e1       	ldi	r24, 0x10	; 16
 3fc:	0e 94 e5 00 	call	0x1ca	; 0x1ca <enc28j60PhyWrite>

	// Enable interrutps
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
 400:	40 ec       	ldi	r20, 0xC0	; 192
 402:	6b e1       	ldi	r22, 0x1B	; 27
 404:	80 e8       	ldi	r24, 0x80	; 128
 406:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// Enable packet reception
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);	
 40a:	44 e0       	ldi	r20, 0x04	; 4
 40c:	6f e1       	ldi	r22, 0x1F	; 31
 40e:	80 e8       	ldi	r24, 0x80	; 128
 410:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
}
 414:	cf 91       	pop	r28
 416:	1f 91       	pop	r17
 418:	0f 91       	pop	r16
 41a:	08 95       	ret

0000041c <enc28j60IsLinkUp>:

// -----------------------------------------------------------------------------

uint8_t enc28j60IsLinkUp(void)
{
	return (enc28j60PhyReadH(PHSTAT2) & PHSTAT2H_LSTAT);
 41c:	81 e1       	ldi	r24, 0x11	; 17
 41e:	0e 94 bb 00 	call	0x176	; 0x176 <enc28j60PhyReadH>
}
 422:	84 70       	andi	r24, 0x04	; 4
 424:	08 95       	ret

00000426 <enc28j60PollPacket>:

// -----------------------------------------------------------------------------
// read an ethernet packet, returns the amount of bytes read.
uint8_t enc28j60PollPacket( uint8_t maxlen, uint8_t* from_mac,uint8_t* buf) 
{
 426:	8f 92       	push	r8
 428:	9f 92       	push	r9
 42a:	af 92       	push	r10
 42c:	bf 92       	push	r11
 42e:	cf 92       	push	r12
 430:	df 92       	push	r13
 432:	ef 92       	push	r14
 434:	ff 92       	push	r15
 436:	0f 93       	push	r16
 438:	1f 93       	push	r17
 43a:	cf 93       	push	r28
 43c:	c8 2f       	mov	r28, r24
 43e:	5b 01       	movw	r10, r22
 440:	6a 01       	movw	r12, r20
	uint8_t len;
	uint16_t currentPacketPtr = gNextPacketPtr;
 442:	e0 90 0a 01 	lds	r14, 0x010A	; 0x80010a <__data_end>
 446:	f0 90 0b 01 	lds	r15, 0x010B	; 0x80010b <__data_end+0x1>
	uint16_t address;
	uint16_t framelen;

	// check if a packet has been received and buffered
	enc28j60SetBank(1);
 44a:	81 e0       	ldi	r24, 0x01	; 1
 44c:	0e 94 7c 00 	call	0xf8	; 0xf8 <enc28j60SetBank>
	if (enc28j60ReadReg(EPKTCNT) == 0)
 450:	69 e3       	ldi	r22, 0x39	; 57
 452:	80 e0       	ldi	r24, 0x00	; 0
 454:	0e 94 5a 00 	call	0xb4	; 0xb4 <enc28j60ReadOp>
 458:	88 23       	and	r24, r24
 45a:	09 f4       	brne	.+2      	; 0x45e <enc28j60PollPacket+0x38>
 45c:	87 c0       	rjmp	.+270    	; 0x56c <__stack+0x6d>
	{
		return (0);
	}

	enc28j60SetBank(0);
 45e:	80 e0       	ldi	r24, 0x00	; 0
 460:	0e 94 7c 00 	call	0xf8	; 0xf8 <enc28j60SetBank>
	// Somehow, the read pointer is NOT already at the start of the next packet
	// even though we leave it in that state
	enc28j60WriteReg(ERDPTL, (gNextPacketPtr&0xff));    
 464:	4e 2d       	mov	r20, r14
 466:	60 e0       	ldi	r22, 0x00	; 0
 468:	80 e4       	ldi	r24, 0x40	; 64
 46a:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(ERDPTH, (gNextPacketPtr)>>8);
 46e:	4f 2d       	mov	r20, r15
 470:	61 e0       	ldi	r22, 0x01	; 1
 472:	80 e4       	ldi	r24, 0x40	; 64
 474:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// Read the next packet pointer	
	gNextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
 478:	60 e0       	ldi	r22, 0x00	; 0
 47a:	8a e3       	ldi	r24, 0x3A	; 58
 47c:	0e 94 5a 00 	call	0xb4	; 0xb4 <enc28j60ReadOp>
 480:	08 2f       	mov	r16, r24
	gNextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
 482:	60 e0       	ldi	r22, 0x00	; 0
 484:	8a e3       	ldi	r24, 0x3A	; 58
 486:	0e 94 5a 00 	call	0xb4	; 0xb4 <enc28j60ReadOp>
 48a:	10 e0       	ldi	r17, 0x00	; 0
 48c:	18 2b       	or	r17, r24
 48e:	10 93 0b 01 	sts	0x010B, r17	; 0x80010b <__data_end+0x1>
 492:	00 93 0a 01 	sts	0x010A, r16	; 0x80010a <__data_end>
	// read the frame length
	framelen  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
 496:	60 e0       	ldi	r22, 0x00	; 0
 498:	8a e3       	ldi	r24, 0x3A	; 58
 49a:	0e 94 5a 00 	call	0xb4	; 0xb4 <enc28j60ReadOp>
 49e:	88 2e       	mov	r8, r24
 4a0:	91 2c       	mov	r9, r1
	framelen |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
 4a2:	60 e0       	ldi	r22, 0x00	; 0
 4a4:	8a e3       	ldi	r24, 0x3A	; 58
 4a6:	0e 94 5a 00 	call	0xb4	; 0xb4 <enc28j60ReadOp>
 4aa:	94 01       	movw	r18, r8
 4ac:	38 2b       	or	r19, r24
 4ae:	c9 01       	movw	r24, r18
	if (maxlen> framelen-14){ // subtract eth source, dest and length fields
 4b0:	2c 2f       	mov	r18, r28
 4b2:	30 e0       	ldi	r19, 0x00	; 0
 4b4:	ac 01       	movw	r20, r24
 4b6:	4e 50       	subi	r20, 0x0E	; 14
 4b8:	51 09       	sbc	r21, r1
 4ba:	42 17       	cp	r20, r18
 4bc:	53 07       	cpc	r21, r19
 4be:	10 f4       	brcc	.+4      	; 0x4c4 <enc28j60PollPacket+0x9e>
		maxlen=framelen-14;
 4c0:	c2 ef       	ldi	r28, 0xF2	; 242
 4c2:	c8 0f       	add	r28, r24
	}
	address = currentPacketPtr + ETH_SRC_MAC_P + 6;	 // note +6 for receive vectors
 4c4:	47 01       	movw	r8, r14
 4c6:	3c e0       	ldi	r19, 0x0C	; 12
 4c8:	83 0e       	add	r8, r19
 4ca:	91 1c       	adc	r9, r1
	if (address > RXSTOP_INIT)
 4cc:	8e ef       	ldi	r24, 0xFE	; 254
 4ce:	88 16       	cp	r8, r24
 4d0:	89 e1       	ldi	r24, 0x19	; 25
 4d2:	98 06       	cpc	r9, r24
 4d4:	28 f0       	brcs	.+10     	; 0x4e0 <enc28j60PollPacket+0xba>
	{
		address -= (RXSTOP_INIT - RXSTART_INIT + 1);
 4d6:	47 01       	movw	r8, r14
 4d8:	22 ef       	ldi	r18, 0xF2	; 242
 4da:	82 1a       	sub	r8, r18
 4dc:	29 e1       	ldi	r18, 0x19	; 25
 4de:	92 0a       	sbc	r9, r18
	}
	enc28j60WriteReg(ERDPTL, address & 0xff);
 4e0:	48 2d       	mov	r20, r8
 4e2:	60 e0       	ldi	r22, 0x00	; 0
 4e4:	80 e4       	ldi	r24, 0x40	; 64
 4e6:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(ERDPTH, (address)>>8);
 4ea:	49 2d       	mov	r20, r9
 4ec:	61 e0       	ldi	r22, 0x01	; 1
 4ee:	80 e4       	ldi	r24, 0x40	; 64
 4f0:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60ReadBuffer(6, from_mac);		
 4f4:	b5 01       	movw	r22, r10
 4f6:	86 e0       	ldi	r24, 0x06	; 6
 4f8:	0e 94 91 00 	call	0x122	; 0x122 <enc28j60ReadBuffer>
	// A value of less than 0x05dc in the EtherType has to be interpreted as
	// length. This is what we do here.
	// The length is 16 bit. The upper 8 bits must be zero
	// otherwise it is not our packet.
	len = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
 4fc:	60 e0       	ldi	r22, 0x00	; 0
 4fe:	8a e3       	ldi	r24, 0x3A	; 58
 500:	0e 94 5a 00 	call	0xb4	; 0xb4 <enc28j60ReadOp>
	if (len !=0){
 504:	81 11       	cpse	r24, r1
 506:	0c c0       	rjmp	.+24     	; 0x520 <__stack+0x21>
		len=0;
		goto NEXTPACKET;
	}
	// read the lower byte of the length field
	len = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
 508:	60 e0       	ldi	r22, 0x00	; 0
 50a:	8a e3       	ldi	r24, 0x3A	; 58
 50c:	0e 94 5a 00 	call	0xb4	; 0xb4 <enc28j60ReadOp>
 510:	8c 17       	cp	r24, r28
 512:	08 f4       	brcc	.+2      	; 0x516 <__stack+0x17>
 514:	c8 2f       	mov	r28, r24
	// limit retrieve length to maxlen, ignoring anything else
	if (len > maxlen) {
		len=maxlen;
	}
	// copy payload data from the receive buffer
	enc28j60ReadBuffer(len, buf);		
 516:	b6 01       	movw	r22, r12
 518:	8c 2f       	mov	r24, r28
 51a:	0e 94 91 00 	call	0x122	; 0x122 <enc28j60ReadBuffer>
 51e:	01 c0       	rjmp	.+2      	; 0x522 <__stack+0x23>
	// length. This is what we do here.
	// The length is 16 bit. The upper 8 bits must be zero
	// otherwise it is not our packet.
	len = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	if (len !=0){
		len=0;
 520:	c0 e0       	ldi	r28, 0x00	; 0
NEXTPACKET:
        // Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out.
	// However, compensate for the errata point 13, rev B4: enver write an even address!
	if ((gNextPacketPtr - 1 < RXSTART_INIT) 
		|| (gNextPacketPtr -1 > RXSTOP_INIT))
 522:	78 01       	movw	r14, r16
 524:	31 e0       	ldi	r19, 0x01	; 1
 526:	e3 1a       	sub	r14, r19
 528:	f1 08       	sbc	r15, r1

NEXTPACKET:
        // Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out.
	// However, compensate for the errata point 13, rev B4: enver write an even address!
	if ((gNextPacketPtr - 1 < RXSTART_INIT) 
 52a:	8e ef       	ldi	r24, 0xFE	; 254
 52c:	e8 16       	cp	r14, r24
 52e:	89 e1       	ldi	r24, 0x19	; 25
 530:	f8 06       	cpc	r15, r24
 532:	58 f0       	brcs	.+22     	; 0x54a <__stack+0x4b>
		|| (gNextPacketPtr -1 > RXSTOP_INIT))
	{
		enc28j60WriteReg(ERXRDPTL, (RXSTOP_INIT)&0xFF);
 534:	4d ef       	ldi	r20, 0xFD	; 253
 536:	6c e0       	ldi	r22, 0x0C	; 12
 538:	80 e4       	ldi	r24, 0x40	; 64
 53a:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
		enc28j60WriteReg(ERXRDPTH, (RXSTOP_INIT)>>8);
 53e:	49 e1       	ldi	r20, 0x19	; 25
 540:	6d e0       	ldi	r22, 0x0D	; 13
 542:	80 e4       	ldi	r24, 0x40	; 64
 544:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
 548:	0b c0       	rjmp	.+22     	; 0x560 <__stack+0x61>
	}
	else
	{
		enc28j60WriteReg(ERXRDPTL, (gNextPacketPtr-1)&0xFF);
 54a:	4f ef       	ldi	r20, 0xFF	; 255
 54c:	40 0f       	add	r20, r16
 54e:	6c e0       	ldi	r22, 0x0C	; 12
 550:	80 e4       	ldi	r24, 0x40	; 64
 552:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
		enc28j60WriteReg(ERXRDPTH, (gNextPacketPtr-1)>>8);
 556:	4f 2d       	mov	r20, r15
 558:	6d e0       	ldi	r22, 0x0D	; 13
 55a:	80 e4       	ldi	r24, 0x40	; 64
 55c:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	}

	// Decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
 560:	40 e4       	ldi	r20, 0x40	; 64
 562:	6e e1       	ldi	r22, 0x1E	; 30
 564:	80 e8       	ldi	r24, 0x80	; 128
 566:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
        return (len);
 56a:	8c 2f       	mov	r24, r28
}
 56c:	cf 91       	pop	r28
 56e:	1f 91       	pop	r17
 570:	0f 91       	pop	r16
 572:	ff 90       	pop	r15
 574:	ef 90       	pop	r14
 576:	df 90       	pop	r13
 578:	cf 90       	pop	r12
 57a:	bf 90       	pop	r11
 57c:	af 90       	pop	r10
 57e:	9f 90       	pop	r9
 580:	8f 90       	pop	r8
 582:	08 95       	ret

00000584 <enc28j60gratuitousARPrequest>:

//------------------------------------------------------------------------------
// send gratuitous ARP request (spontaneous arp request) to teach any
// switches what our mac is.
void enc28j60gratuitousARPrequest( uint8_t* macaddr)
{
 584:	ef 92       	push	r14
 586:	ff 92       	push	r15
 588:	0f 93       	push	r16
 58a:	1f 93       	push	r17
 58c:	cf 93       	push	r28
 58e:	df 93       	push	r29
 590:	7c 01       	movw	r14, r24
	uint8_t i = 0;
	uint16_t address;
	enc28j60SetBank(0);
 592:	80 e0       	ldi	r24, 0x00	; 0
 594:	0e 94 7c 00 	call	0xf8	; 0xf8 <enc28j60SetBank>
	
	// (control byte, and SRC MAC have already been set during init)
	
#ifdef ENC28J60_HAS_PENDING_TRANSMIT_ON_TRANSMIT	
	// Check no transmit in progress
	while (enc28j60ReadOp(ENC28J60_READ_CTRL_REG, ECON1) & ECON1_TXRTS)
 598:	10 c0       	rjmp	.+32     	; 0x5ba <enc28j60gratuitousARPrequest+0x36>
	{		
		// Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
		if( (enc28j60ReadReg(EIR) & EIR_TXERIF) )
 59a:	6c e1       	ldi	r22, 0x1C	; 28
 59c:	80 e0       	ldi	r24, 0x00	; 0
 59e:	0e 94 5a 00 	call	0xb4	; 0xb4 <enc28j60ReadOp>
 5a2:	81 ff       	sbrs	r24, 1
 5a4:	0a c0       	rjmp	.+20     	; 0x5ba <enc28j60gratuitousARPrequest+0x36>
		{
			enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRST);
 5a6:	40 e8       	ldi	r20, 0x80	; 128
 5a8:	6f e1       	ldi	r22, 0x1F	; 31
 5aa:	80 e8       	ldi	r24, 0x80	; 128
 5ac:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
			enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRST);
 5b0:	40 e8       	ldi	r20, 0x80	; 128
 5b2:	6f e1       	ldi	r22, 0x1F	; 31
 5b4:	80 ea       	ldi	r24, 0xA0	; 160
 5b6:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	
	// (control byte, and SRC MAC have already been set during init)
	
#ifdef ENC28J60_HAS_PENDING_TRANSMIT_ON_TRANSMIT	
	// Check no transmit in progress
	while (enc28j60ReadOp(ENC28J60_READ_CTRL_REG, ECON1) & ECON1_TXRTS)
 5ba:	6f e1       	ldi	r22, 0x1F	; 31
 5bc:	80 e0       	ldi	r24, 0x00	; 0
 5be:	0e 94 5a 00 	call	0xb4	; 0xb4 <enc28j60ReadOp>
 5c2:	83 fd       	sbrc	r24, 3
 5c4:	ea cf       	rjmp	.-44     	; 0x59a <enc28j60gratuitousARPrequest+0x16>
	}
#endif
	// Set the write pointer to start of transmit buffer area
	// +1 to skip the per packet control byte and write directly the mac
	// The control byte was set to zero during initialisation and remains like that.
        enc28j60WriteReg(EWRPTL, (TXSTART_INIT+1)&0xFF);
 5c6:	40 e0       	ldi	r20, 0x00	; 0
 5c8:	62 e0       	ldi	r22, 0x02	; 2
 5ca:	80 e4       	ldi	r24, 0x40	; 64
 5cc:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
        enc28j60WriteReg(EWRPTH, (TXSTART_INIT+1)>>8);
 5d0:	4a e1       	ldi	r20, 0x1A	; 26
 5d2:	63 e0       	ldi	r22, 0x03	; 3
 5d4:	80 e4       	ldi	r24, 0x40	; 64
 5d6:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
 5da:	c6 e0       	ldi	r28, 0x06	; 6
	// write a broadcase destination mac (all ff):
	while (i < 6)
	{
		enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0xFF);	
 5dc:	4f ef       	ldi	r20, 0xFF	; 255
 5de:	60 e0       	ldi	r22, 0x00	; 0
 5e0:	8a e7       	ldi	r24, 0x7A	; 122
 5e2:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
 5e6:	c1 50       	subi	r28, 0x01	; 1
	// +1 to skip the per packet control byte and write directly the mac
	// The control byte was set to zero during initialisation and remains like that.
        enc28j60WriteReg(EWRPTL, (TXSTART_INIT+1)&0xFF);
        enc28j60WriteReg(EWRPTH, (TXSTART_INIT+1)>>8);
	// write a broadcase destination mac (all ff):
	while (i < 6)
 5e8:	c9 f7       	brne	.-14     	; 0x5dc <enc28j60gratuitousARPrequest+0x58>
		i++;
	}
	// The mac in the ethernet field does not need to be changed.
	// Set the write pointer to the first byte of the EtherType field 
	address = TXSTART_INIT + 1 + ETH_TYPE_H_P;
	enc28j60WriteReg(EWRPTL, address & 0xFF);
 5ea:	4c e0       	ldi	r20, 0x0C	; 12
 5ec:	62 e0       	ldi	r22, 0x02	; 2
 5ee:	80 e4       	ldi	r24, 0x40	; 64
 5f0:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(EWRPTH, address >> 8);
 5f4:	4a e1       	ldi	r20, 0x1A	; 26
 5f6:	63 e0       	ldi	r22, 0x03	; 3
 5f8:	80 e4       	ldi	r24, 0x40	; 64
 5fa:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
 5fe:	cc e6       	ldi	r28, 0x6C	; 108
 600:	d0 e0       	ldi	r29, 0x00	; 0
 602:	06 e7       	ldi	r16, 0x76	; 118
 604:	10 e0       	ldi	r17, 0x00	; 0
	// there are 10 fixed bytes in the arp request
	i=0;
        while (i<10){
		enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, pgm_read_byte(arpreqhdr+i));	
 606:	fe 01       	movw	r30, r28
 608:	44 91       	lpm	r20, Z
 60a:	60 e0       	ldi	r22, 0x00	; 0
 60c:	8a e7       	ldi	r24, 0x7A	; 122
 60e:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
 612:	21 96       	adiw	r28, 0x01	; 1
	address = TXSTART_INIT + 1 + ETH_TYPE_H_P;
	enc28j60WriteReg(EWRPTL, address & 0xFF);
	enc28j60WriteReg(EWRPTH, address >> 8);
	// there are 10 fixed bytes in the arp request
	i=0;
        while (i<10){
 614:	c0 17       	cp	r28, r16
 616:	d1 07       	cpc	r29, r17
 618:	b1 f7       	brne	.-20     	; 0x606 <enc28j60gratuitousARPrequest+0x82>
 61a:	e7 01       	movw	r28, r14
 61c:	87 01       	movw	r16, r14
 61e:	0a 5f       	subi	r16, 0xFA	; 250
 620:	1f 4f       	sbci	r17, 0xFF	; 255
		i++;
        }
	i=0;
	while (i < 6)
	{
		enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, macaddr[i]);	
 622:	49 91       	ld	r20, Y+
 624:	60 e0       	ldi	r22, 0x00	; 0
 626:	8a e7       	ldi	r24, 0x7A	; 122
 628:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
        while (i<10){
		enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, pgm_read_byte(arpreqhdr+i));	
		i++;
        }
	i=0;
	while (i < 6)
 62c:	0c 17       	cp	r16, r28
 62e:	1d 07       	cpc	r17, r29
 630:	c1 f7       	brne	.-16     	; 0x622 <enc28j60gratuitousARPrequest+0x9e>
 632:	06 e0       	ldi	r16, 0x06	; 6
 634:	11 e0       	ldi	r17, 0x01	; 1
 636:	0f 2e       	mov	r0, r31
 638:	fa e0       	ldi	r31, 0x0A	; 10
 63a:	ef 2e       	mov	r14, r31
 63c:	f1 e0       	ldi	r31, 0x01	; 1
 63e:	ff 2e       	mov	r15, r31
 640:	f0 2d       	mov	r31, r0
 642:	e8 01       	movw	r28, r16
		i++;
	}
	i=0;
	while (i < 4)
	{
		enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, myip[i]);	
 644:	49 91       	ld	r20, Y+
 646:	60 e0       	ldi	r22, 0x00	; 0
 648:	8a e7       	ldi	r24, 0x7A	; 122
 64a:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	{
		enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, macaddr[i]);	
		i++;
	}
	i=0;
	while (i < 4)
 64e:	ce 15       	cp	r28, r14
 650:	df 05       	cpc	r29, r15
 652:	c1 f7       	brne	.-16     	; 0x644 <enc28j60gratuitousARPrequest+0xc0>
 654:	c6 e0       	ldi	r28, 0x06	; 6
	}
	// target data:
	i=0;
	while (i < 6)
	{
		enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0xff);	
 656:	4f ef       	ldi	r20, 0xFF	; 255
 658:	60 e0       	ldi	r22, 0x00	; 0
 65a:	8a e7       	ldi	r24, 0x7A	; 122
 65c:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
 660:	c1 50       	subi	r28, 0x01	; 1
		enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, myip[i]);	
		i++;
	}
	// target data:
	i=0;
	while (i < 6)
 662:	c9 f7       	brne	.-14     	; 0x656 <enc28j60gratuitousARPrequest+0xd2>
	}
	// to self, for gratuitous arp:
	i=0;
	while (i < 4)
	{
		enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, myip[i]);	
 664:	f8 01       	movw	r30, r16
 666:	41 91       	ld	r20, Z+
 668:	8f 01       	movw	r16, r30
 66a:	60 e0       	ldi	r22, 0x00	; 0
 66c:	8a e7       	ldi	r24, 0x7A	; 122
 66e:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
		enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0xff);	
		i++;
	}
	// to self, for gratuitous arp:
	i=0;
	while (i < 4)
 672:	0e 15       	cp	r16, r14
 674:	1f 05       	cpc	r17, r15
 676:	b1 f7       	brne	.-20     	; 0x664 <enc28j60gratuitousARPrequest+0xe0>
		enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, myip[i]);	
		i++;
	}
	// Set the TXND pointer to correspond to the payload size given
	address = (TXSTART_INIT + 42 );
	enc28j60WriteReg(ETXNDL, address & 0xFF);
 678:	49 e2       	ldi	r20, 0x29	; 41
 67a:	66 e0       	ldi	r22, 0x06	; 6
 67c:	80 e4       	ldi	r24, 0x40	; 64
 67e:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(ETXNDH, address >> 8);
 682:	4a e1       	ldi	r20, 0x1A	; 26
 684:	67 e0       	ldi	r22, 0x07	; 7
 686:	80 e4       	ldi	r24, 0x40	; 64
 688:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	
	// Send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
 68c:	48 e0       	ldi	r20, 0x08	; 8
 68e:	6f e1       	ldi	r22, 0x1F	; 31
 690:	80 e8       	ldi	r24, 0x80	; 128
 692:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
}
 696:	df 91       	pop	r29
 698:	cf 91       	pop	r28
 69a:	1f 91       	pop	r17
 69c:	0f 91       	pop	r16
 69e:	ff 90       	pop	r15
 6a0:	ef 90       	pop	r14
 6a2:	08 95       	ret

000006a4 <enc28j60TransmitPacket>:
//------------------------------------------------------------------------------
// Send a packet.
// The to_mac contains the mac of the receiver
// len is the length of data in the buffer buf.
void enc28j60TransmitPacket( uint8_t len, uint8_t* to_mac,uint8_t* buf) 
{
 6a4:	ef 92       	push	r14
 6a6:	ff 92       	push	r15
 6a8:	0f 93       	push	r16
 6aa:	1f 93       	push	r17
 6ac:	cf 93       	push	r28
 6ae:	df 93       	push	r29
 6b0:	c8 2f       	mov	r28, r24
 6b2:	7b 01       	movw	r14, r22
 6b4:	8a 01       	movw	r16, r20
	uint16_t address;
	enc28j60SetBank(0);
 6b6:	80 e0       	ldi	r24, 0x00	; 0
 6b8:	0e 94 7c 00 	call	0xf8	; 0xf8 <enc28j60SetBank>
	
	// (control byte, and SRC MAC have already been set during init)
	
#ifdef ENC28J60_HAS_PENDING_TRANSMIT_ON_TRANSMIT	
	// Check no transmit in progress
	while (enc28j60ReadOp(ENC28J60_READ_CTRL_REG, ECON1) & ECON1_TXRTS)
 6bc:	10 c0       	rjmp	.+32     	; 0x6de <enc28j60TransmitPacket+0x3a>
	{		
		// Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
		if( (enc28j60ReadReg(EIR) & EIR_TXERIF) )
 6be:	6c e1       	ldi	r22, 0x1C	; 28
 6c0:	80 e0       	ldi	r24, 0x00	; 0
 6c2:	0e 94 5a 00 	call	0xb4	; 0xb4 <enc28j60ReadOp>
 6c6:	81 ff       	sbrs	r24, 1
 6c8:	0a c0       	rjmp	.+20     	; 0x6de <enc28j60TransmitPacket+0x3a>
		{
			enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRST);
 6ca:	40 e8       	ldi	r20, 0x80	; 128
 6cc:	6f e1       	ldi	r22, 0x1F	; 31
 6ce:	80 e8       	ldi	r24, 0x80	; 128
 6d0:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
			enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRST);
 6d4:	40 e8       	ldi	r20, 0x80	; 128
 6d6:	6f e1       	ldi	r22, 0x1F	; 31
 6d8:	80 ea       	ldi	r24, 0xA0	; 160
 6da:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	
	// (control byte, and SRC MAC have already been set during init)
	
#ifdef ENC28J60_HAS_PENDING_TRANSMIT_ON_TRANSMIT	
	// Check no transmit in progress
	while (enc28j60ReadOp(ENC28J60_READ_CTRL_REG, ECON1) & ECON1_TXRTS)
 6de:	6f e1       	ldi	r22, 0x1F	; 31
 6e0:	80 e0       	ldi	r24, 0x00	; 0
 6e2:	0e 94 5a 00 	call	0xb4	; 0xb4 <enc28j60ReadOp>
 6e6:	83 fd       	sbrc	r24, 3
 6e8:	ea cf       	rjmp	.-44     	; 0x6be <enc28j60TransmitPacket+0x1a>
	}
#endif
	// Set the write pointer to start of transmit buffer area
	// +1 to skip the per packet control byte and write directly the mac
	// The control byte was set to zero during initialisation and remains like that.
        enc28j60WriteReg(EWRPTL, (TXSTART_INIT+1)&0xFF);
 6ea:	40 e0       	ldi	r20, 0x00	; 0
 6ec:	62 e0       	ldi	r22, 0x02	; 2
 6ee:	80 e4       	ldi	r24, 0x40	; 64
 6f0:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
        enc28j60WriteReg(EWRPTH, (TXSTART_INIT+1)>>8);
 6f4:	4a e1       	ldi	r20, 0x1A	; 26
 6f6:	63 e0       	ldi	r22, 0x03	; 3
 6f8:	80 e4       	ldi	r24, 0x40	; 64
 6fa:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteBuffer(6, to_mac);
 6fe:	b7 01       	movw	r22, r14
 700:	86 e0       	ldi	r24, 0x06	; 6
 702:	0e 94 a5 00 	call	0x14a	; 0x14a <enc28j60WriteBuffer>

	// Set the write pointer to the first byte of the EtherType field 
	// (field after the mac address). This is the 802.3 length field.
	address = TXSTART_INIT + 1 + ETH_TYPE_H_P;
	enc28j60WriteReg(EWRPTL, address & 0xFF);
 706:	4c e0       	ldi	r20, 0x0C	; 12
 708:	62 e0       	ldi	r22, 0x02	; 2
 70a:	80 e4       	ldi	r24, 0x40	; 64
 70c:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(EWRPTH, address >> 8);
 710:	4a e1       	ldi	r20, 0x1A	; 26
 712:	63 e0       	ldi	r22, 0x03	; 3
 714:	80 e4       	ldi	r24, 0x40	; 64
 716:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// write the length of the data in the ethernet type field.
	// The type field to be interpreted by the receiver as ieee802.3 length if
	// the value is less than 0x05dc (see e.g. http://www.cavebear.com/archive/cavebear/Ethernet/type.html ):
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0);	
 71a:	40 e0       	ldi	r20, 0x00	; 0
 71c:	60 e0       	ldi	r22, 0x00	; 0
 71e:	8a e7       	ldi	r24, 0x7A	; 122
 720:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, len);	
 724:	4c 2f       	mov	r20, r28
 726:	60 e0       	ldi	r22, 0x00	; 0
 728:	8a e7       	ldi	r24, 0x7A	; 122
 72a:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	// Copy the payload into the transmit buffer
	enc28j60WriteBuffer(len, buf); // remove dest mac and write the rest
 72e:	b8 01       	movw	r22, r16
 730:	8c 2f       	mov	r24, r28
 732:	0e 94 a5 00 	call	0x14a	; 0x14a <enc28j60WriteBuffer>
	// Set the TXND pointer to correspond to the payload size given
	address = (TXSTART_INIT + ETH_HEADER_LEN + len );
 736:	d0 e0       	ldi	r29, 0x00	; 0
 738:	c3 5f       	subi	r28, 0xF3	; 243
 73a:	d5 4e       	sbci	r29, 0xE5	; 229
	enc28j60WriteReg(ETXNDL, address & 0xFF);
 73c:	4c 2f       	mov	r20, r28
 73e:	66 e0       	ldi	r22, 0x06	; 6
 740:	80 e4       	ldi	r24, 0x40	; 64
 742:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	enc28j60WriteReg(ETXNDH, address >> 8);
 746:	4d 2f       	mov	r20, r29
 748:	67 e0       	ldi	r22, 0x07	; 7
 74a:	80 e4       	ldi	r24, 0x40	; 64
 74c:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
	
	// Send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
 750:	48 e0       	ldi	r20, 0x08	; 8
 752:	6f e1       	ldi	r22, 0x1F	; 31
 754:	80 e8       	ldi	r24, 0x80	; 128
 756:	0e 94 6f 00 	call	0xde	; 0xde <enc28j60WriteOp>
}
 75a:	df 91       	pop	r29
 75c:	cf 91       	pop	r28
 75e:	1f 91       	pop	r17
 760:	0f 91       	pop	r16
 762:	ff 90       	pop	r15
 764:	ef 90       	pop	r14
 766:	08 95       	ret

00000768 <usart_init>:
#define USART_BAUDRATE 9600
#define BAUD_PRESCALE ((F_CPU/16/USART_BAUDRATE)-1) //UBRR (USART BAUD RATE REGISTER) degeri datasheet de sayfa 205.

void usart_init(void){
	
	UBRR0L = BAUD_PRESCALE;			/* Load lower 8-bits of the baud rate */
 768:	80 e5       	ldi	r24, 0x50	; 80
 76a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	UBRR0H = (BAUD_PRESCALE >> 8);		/* Load upper 8-bits*/
 76e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
	UCSR0B =  (1 << TXEN0);	//enable the receiver and transmitter.
 772:	88 e0       	ldi	r24, 0x08	; 8
 774:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	UCSR0C = (1 << UCSZ00) | (1 << UCSZ01);
 778:	86 e0       	ldi	r24, 0x06	; 6
 77a:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 77e:	08 95       	ret

00000780 <main>:
}

int main(void)
{
	usart_init();
 780:	0e 94 b4 03 	call	0x768	; 0x768 <usart_init>
	uint8_t ledon = 0;
	uint8_t j = 0;
	// Set the clock prescaler to divide-by-1
	CLKPR=(1<<CLKPCE);
 784:	e1 e6       	ldi	r30, 0x61	; 97
 786:	f0 e0       	ldi	r31, 0x00	; 0
 788:	80 e8       	ldi	r24, 0x80	; 128
 78a:	80 83       	st	Z, r24
	CLKPR=0;
 78c:	10 82       	st	Z, r1
 78e:	83 e2       	ldi	r24, 0x23	; 35
 790:	94 ef       	ldi	r25, 0xF4	; 244
 792:	01 97       	sbiw	r24, 0x01	; 1
 794:	f1 f7       	brne	.-4      	; 0x792 <main+0x12>
 796:	00 c0       	rjmp	.+0      	; 0x798 <main+0x18>
 798:	00 00       	nop
	
	_delay_ms(20);
	
	// initialize enc28j60
	enc28j60Init(mymac);
 79a:	80 e0       	ldi	r24, 0x00	; 0
 79c:	91 e0       	ldi	r25, 0x01	; 1
 79e:	0e 94 0f 01 	call	0x21e	; 0x21e <enc28j60Init>
 7a2:	97 e4       	ldi	r25, 0x47	; 71
 7a4:	e8 ee       	ldi	r30, 0xE8	; 232
 7a6:	f1 e0       	ldi	r31, 0x01	; 1
 7a8:	91 50       	subi	r25, 0x01	; 1
 7aa:	e0 40       	sbci	r30, 0x00	; 0
 7ac:	f0 40       	sbci	r31, 0x00	; 0
 7ae:	e1 f7       	brne	.-8      	; 0x7a8 <main+0x28>
 7b0:	00 c0       	rjmp	.+0      	; 0x7b2 <main+0x32>
 7b2:	00 00       	nop
	
	

	// wait until the link is up then send a gratuitous ARP
	// to inform any conected switch about my existence
	while(!enc28j60IsLinkUp());
 7b4:	0e 94 0e 02 	call	0x41c	; 0x41c <enc28j60IsLinkUp>
 7b8:	88 23       	and	r24, r24
 7ba:	e1 f3       	breq	.-8      	; 0x7b4 <main+0x34>
 7bc:	27 e4       	ldi	r18, 0x47	; 71
 7be:	88 ee       	ldi	r24, 0xE8	; 232
 7c0:	91 e0       	ldi	r25, 0x01	; 1
 7c2:	21 50       	subi	r18, 0x01	; 1
 7c4:	80 40       	sbci	r24, 0x00	; 0
 7c6:	90 40       	sbci	r25, 0x00	; 0
 7c8:	e1 f7       	brne	.-8      	; 0x7c2 <main+0x42>
 7ca:	00 c0       	rjmp	.+0      	; 0x7cc <main+0x4c>
 7cc:	00 00       	nop
	_delay_ms(50);
	enc28j60gratuitousARPrequest(mymac);
 7ce:	80 e0       	ldi	r24, 0x00	; 0
 7d0:	91 e0       	ldi	r25, 0x01	; 1
 7d2:	0e 94 c2 02 	call	0x584	; 0x584 <enc28j60gratuitousARPrequest>

int main(void)
{
	usart_init();
	uint8_t ledon = 0;
	uint8_t j = 0;
 7d6:	c0 e0       	ldi	r28, 0x00	; 0
}

int main(void)
{
	usart_init();
	uint8_t ledon = 0;
 7d8:	d0 e0       	ldi	r29, 0x00	; 0
			 UDR0 ='S';
 		}
 		else
 		{
 			ledon=1;
			UDR0 ='A';
 7da:	06 ec       	ldi	r16, 0xC6	; 198
 7dc:	10 e0       	ldi	r17, 0x00	; 0
 7de:	0f 2e       	mov	r0, r31
 7e0:	f1 e4       	ldi	r31, 0x41	; 65
 7e2:	cf 2e       	mov	r12, r31
 7e4:	f0 2d       	mov	r31, r0
 			ledon=0;
			 UDR0 ='S';
 		}
 		else
 		{
 			ledon=1;
 7e6:	dd 24       	eor	r13, r13
 7e8:	d3 94       	inc	r13
		// toggle LED to acknowledge reception of packet

 		if (ledon)
 		{
 			ledon=0;
			 UDR0 ='S';
 7ea:	0f 2e       	mov	r0, r31
 7ec:	f3 e5       	ldi	r31, 0x53	; 83
 7ee:	ef 2e       	mov	r14, r31
 7f0:	f0 2d       	mov	r31, r0
		}
		// toggle LED to acknowledge reception of packet

 		if (ledon)
 		{
 			ledon=0;
 7f2:	f1 2c       	mov	r15, r1

	//sei();
	while(1)
	{
		// get the next new packet:
		recvlen = enc28j60PollPacket(BUFFER_SIZE,from_to_mac, buf);
 7f4:	4d e0       	ldi	r20, 0x0D	; 13
 7f6:	51 e0       	ldi	r21, 0x01	; 1
 7f8:	60 e1       	ldi	r22, 0x10	; 16
 7fa:	71 e0       	ldi	r23, 0x01	; 1
 7fc:	83 e0       	ldi	r24, 0x03	; 3
 7fe:	0e 94 13 02 	call	0x426	; 0x426 <enc28j60PollPacket>
		if (recvlen==0){
 802:	88 23       	and	r24, r24
 804:	b9 f3       	breq	.-18     	; 0x7f4 <main+0x74>
			continue;
		}
		// toggle LED to acknowledge reception of packet

 		if (ledon)
 806:	dd 23       	and	r29, r29
 808:	21 f0       	breq	.+8      	; 0x812 <main+0x92>
 		{
 			ledon=0;
			 UDR0 ='S';
 80a:	f8 01       	movw	r30, r16
 80c:	e0 82       	st	Z, r14
		}
		// toggle LED to acknowledge reception of packet

 		if (ledon)
 		{
 			ledon=0;
 80e:	df 2d       	mov	r29, r15
 810:	03 c0       	rjmp	.+6      	; 0x818 <main+0x98>
			 UDR0 ='S';
 		}
 		else
 		{
 			ledon=1;
			UDR0 ='A';
 812:	f8 01       	movw	r30, r16
 814:	c0 82       	st	Z, r12
 			ledon=0;
			 UDR0 ='S';
 		}
 		else
 		{
 			ledon=1;
 816:	dd 2d       	mov	r29, r13
			UDR0 ='A';
 		}

		// set pins on port D according to user data received
		PORTD=buf[1];
 818:	ed e0       	ldi	r30, 0x0D	; 13
 81a:	f1 e0       	ldi	r31, 0x01	; 1
 81c:	81 81       	ldd	r24, Z+1	; 0x01
 81e:	8b b9       	out	0x0b, r24	; 11
		//
		j++;
 820:	cf 5f       	subi	r28, 0xFF	; 255
		//buf[0] contains a sequence number we pass it back
		buf[1]=PINC; // read all 8 pins, PC0 to PC7
 822:	86 b1       	in	r24, 0x06	; 6
 824:	81 83       	std	Z+1, r24	; 0x01
		buf[2]=j; // some data for demo purposes
 826:	c2 83       	std	Z+2, r28	; 0x02
		enc28j60TransmitPacket(BUFFER_SIZE, from_to_mac,buf);
 828:	af 01       	movw	r20, r30
 82a:	60 e1       	ldi	r22, 0x10	; 16
 82c:	71 e0       	ldi	r23, 0x01	; 1
 82e:	83 e0       	ldi	r24, 0x03	; 3
 830:	0e 94 52 03 	call	0x6a4	; 0x6a4 <enc28j60TransmitPacket>
 834:	df cf       	rjmp	.-66     	; 0x7f4 <main+0x74>

00000836 <_exit>:
 836:	f8 94       	cli

00000838 <__stop_program>:
 838:	ff cf       	rjmp	.-2      	; 0x838 <__stop_program>
